<div class="container-fluid form-horizontal">

  <div class="form-group">
    <div class="col-md-5 sm-label-right">
      Number of deployed containers
    </div>
    <div class="col-md-2"><input type="number"
                                 class="form-control input-sm no-spel"
                                 ng-pattern="basicSettingsCtrl.detailPattern"
                                 name="capacity"
                                 ng-model="$ctrl.command.capacity.desired"/></div>
  </div>

  <div class="form-group">
    <div class="col-md-5 sm-label-right">
      Reserved compute units
    </div>
    <div class="col-md-2"><input type="number"
                                 class="form-control input-sm no-spel"
                                 ng-pattern="basicSettingsCtrl.detailPattern"
                                 name="computeUnits"
                                 ng-model="$ctrl.command.computeUnits"/></div>
  </div>

  <div class="form-group">
    <div class="col-md-5 sm-label-right">
      Reserved Memory (MB RAM)
    </div>
    <div class="col-md-2"><input type="number"
                                 class="form-control input-sm no-spel"
                                 ng-pattern="basicSettingsCtrl.detailPattern"
                                 name="memory"
                                 ng-model="$ctrl.command.reservedMemory"/></div>
  </div>


  <br />
  Here, engineers will easily be able to select autoscaling rules based on the CPU utilization of their containers,
  which will allow for fast scaling (less than 30 seconds to start new instances as opposed to 5 minutes with EC2).
  <br />
  <br />
  If an engineer wants to autoscale based on different parameters, such as a message queue length, custom metrics can be
  defined in Cloudwatch and selected here.  This solution will be greatly and easily customizable, and a first-class
  citizen of ECS deployments
</div>
